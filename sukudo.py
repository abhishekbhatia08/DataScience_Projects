{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import cv2\n",
    "import numpy as np\n",
    "import operator\n",
    "from keras.models import load_model\n",
    "from keras.models import model_from_json\n",
    "import sudoku_solver as sol\n",
    "\n",
    "classifier = load_model(\"digit_model.h5\")\n",
    "\n",
    "marge = 4\n",
    "case = 28 + 2 * marge\n",
    "taille_grille = 9 * case\n",
    "\n",
    "cap = cv2.VideoCapture(0)\n",
    "fourcc = cv2.VideoWriter_fourcc(*'XVID')\n",
    "flag = 0\n",
    "out = cv2.VideoWriter('output.avi', fourcc, 30.0, (1080, 620))\n",
    "\n",
    "\n",
    "while True:\n",
    "\n",
    "    ret, frame = cap.read()\n",
    "\n",
    "    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n",
    "    gray = cv2.GaussianBlur(gray, (7, 7), 0)\n",
    "    thresh = cv2.adaptiveThreshold(\n",
    "        gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 9, 2)\n",
    "\n",
    "    contours, hierarchy = cv2.findContours(\n",
    "        thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n",
    "    contour_grille = None\n",
    "    maxArea = 0\n",
    "\n",
    "    for c in contours:\n",
    "        area = cv2.contourArea(c)\n",
    "        if area > 25000:\n",
    "            peri = cv2.arcLength(c, True)\n",
    "            polygone = cv2.approxPolyDP(c, 0.01 * peri, True)\n",
    "            if area > maxArea and len(polygone) == 4:\n",
    "                contour_grille = polygone\n",
    "                maxArea = area\n",
    "\n",
    "    if contour_grille is not None:\n",
    "        cv2.drawContours(frame, [contour_grille], 0, (0, 255, 0), 2)\n",
    "        points = np.vstack(contour_grille).squeeze()\n",
    "        points = sorted(points, key=operator.itemgetter(1))\n",
    "        if points[0][0] < points[1][0]:\n",
    "            if points[3][0] < points[2][0]:\n",
    "                pts1 = np.float32([points[0], points[1], points[3], points[2]])\n",
    "            else:\n",
    "                pts1 = np.float32([points[0], points[1], points[2], points[3]])\n",
    "        else:\n",
    "            if points[3][0] < points[2][0]:\n",
    "                pts1 = np.float32([points[1], points[0], points[3], points[2]])\n",
    "            else:\n",
    "                pts1 = np.float32([points[1], points[0], points[2], points[3]])\n",
    "        pts2 = np.float32([[0, 0], [taille_grille, 0], [0, taille_grille], [\n",
    "                          taille_grille, taille_grille]])\n",
    "        M = cv2.getPerspectiveTransform(pts1, pts2)\n",
    "        grille = cv2.warpPerspective(frame, M, (taille_grille, taille_grille))\n",
    "        grille = cv2.cvtColor(grille, cv2.COLOR_BGR2GRAY)\n",
    "        grille = cv2.adaptiveThreshold(\n",
    "            grille, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 7, 3)\n",
    "\n",
    "        cv2.imshow(\"grille\", grille)\n",
    "        if flag == 0:\n",
    "\n",
    "            grille_txt = []\n",
    "            for y in range(9):\n",
    "                ligne = \"\"\n",
    "                for x in range(9):\n",
    "                    y2min = y * case + marge\n",
    "                    y2max = (y + 1) * case - marge\n",
    "                    x2min = x * case + marge\n",
    "                    x2max = (x + 1) * case - marge\n",
    "                    cv2.imwrite(\"mat\" + str(y) + str(x) + \".png\",\n",
    "                                grille[y2min:y2max, x2min:x2max])\n",
    "                    img = grille[y2min:y2max, x2min:x2max]\n",
    "                    x = img.reshape(1, 28, 28, 1)\n",
    "                    if x.sum() > 10000:\n",
    "                        prediction = classifier.predict_classes(x)\n",
    "                        ligne += \"{:d}\".format(prediction[0])\n",
    "                    else:\n",
    "                        ligne += \"{:d}\".format(0)\n",
    "                grille_txt.append(ligne)\n",
    "            print(grille_txt)\n",
    "            result = sol.sudoku(grille_txt)\n",
    "        print(\"Resultat:\", result)\n",
    "\n",
    "        if result is not None:\n",
    "            flag = 1\n",
    "            fond = np.zeros(\n",
    "                shape=(taille_grille, taille_grille, 3), dtype=np.float32)\n",
    "            for y in range(len(result)):\n",
    "                for x in range(len(result[y])):\n",
    "                    if grille_txt[y][x] == \"0\":\n",
    "                        cv2.putText(fond, \"{:d}\".format(result[y][x]), ((\n",
    "                            x) * case + marge + 3, (y + 1) * case - marge - 3), cv2.FONT_HERSHEY_SCRIPT_COMPLEX, 0.9, (0, 0, 255), 1)\n",
    "            M = cv2.getPerspectiveTransform(pts2, pts1)\n",
    "            h, w, c = frame.shape\n",
    "            fondP = cv2.warpPerspective(fond, M, (w, h))\n",
    "            img2gray = cv2.cvtColor(fondP, cv2.COLOR_BGR2GRAY)\n",
    "            ret, mask = cv2.threshold(img2gray, 10, 255, cv2.THRESH_BINARY)\n",
    "            mask = mask.astype('uint8')\n",
    "            mask_inv = cv2.bitwise_not(mask)\n",
    "            img1_bg = cv2.bitwise_and(frame, frame, mask=mask_inv)\n",
    "            img2_fg = cv2.bitwise_and(fondP, fondP, mask=mask).astype('uint8')\n",
    "            dst = cv2.add(img1_bg, img2_fg)\n",
    "            dst = cv2.resize(dst, (1080, 620))\n",
    "            cv2.imshow(\"frame\", dst)\n",
    "            out.write(dst)\n",
    "\n",
    "        else:\n",
    "            frame = cv2.resize(frame, (1080, 620))\n",
    "            cv2.imshow(\"frame\", frame)\n",
    "            out.write(frame)\n",
    "\n",
    "    else:\n",
    "        flag = 0\n",
    "        frame = cv2.resize(frame, (1080, 620))\n",
    "        cv2.imshow(\"frame\", frame)\n",
    "        out.write(frame)\n",
    "\n",
    "    key = cv2.waitKey(1) & 0xFF\n",
    "    if key == ord('q'):\n",
    "        break\n",
    "\n",
    "\n",
    "out.release()\n",
    "cap.release()\n",
    "cv2.destroyAllWindows()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
